{"google":"UA-37678776-4","body":"# Gummi Commander\r\n![Gummi Commander Logo](http://sschmid.com/Libs/Gummi-Commander/Gummi-Commander-128.png)\r\n\r\n## Description\r\nGummi Commander is an Event Command Mapping System for Objective-C.\r\n\r\n## Dependencies\r\nGummi Commander uses\r\n* [Gummi Injection] (http://sschmid.github.com/Gummi-Injection) for Dependency Injection.\r\n* [Gummi Dispatcher] (http://sschmid.github.com/Gummi-Dispatcher) as a Messaging System.\r\n\r\n## Features\r\n* Execute multiple commands by dispatching one event\r\n* Supports nested Async and Sequence Commands\r\n* Add mappings with priority\r\n* Map blocks\r\n* Prevent certain commands to execute by adding Guards\r\n* Inject the corresponding event and other objects of interest into commands\r\n\r\n## How to use Gummi Commander\r\nYou can get started by simply allocating a commandMap.\r\n\r\nThe recommended way to use Gummi Commander is to put your configuration logic into `GCGIExtension` and add them to the Injector.\r\nThe provided `GummiCommanderModule` should be added first.\r\n\r\n```objective-c\r\nGIInjector *injector = [GIInjector sharedInjector];\r\n[injector addModule:[[GummiCommanderModule alloc] init]];\r\n\r\n[injector addModule:[[ApplicationExtension alloc] init]];\r\n[injector addModule:[[TrackingExtension alloc] init]];\r\n\r\n// Maybe add this extension later in the code,\r\n// right before the game starts\r\n[injector addModule:[[GameExtension alloc] init]];\r\n```\r\n\r\n## Commands\r\n* Commands are short lived objects.\r\n* Commands get created and executed when dispatching an event.\r\n* Commands can inject the corresponding event, models and more...\r\n* Commands get destroyed immediately after execution.\r\n\r\n```objective-c\r\n@implementation DropBombCommand\r\ninject(@\"event\", @\"model\")\r\n\r\n- (void)execute {\r\n    self.model.bombs--;\r\n    [self spawnBombAtPosition:self.event.position];\r\n}\r\n...\r\n@end\r\n```\r\n\r\n## Async and Sequence Commands\r\n\r\nGummi Commander also supports nested Async and Sequence Commands.\r\n\r\n* Sequence\r\n  * Async\r\n    * Command\r\n    * Sequence\r\n      * Async\r\n      * Async\r\n      * Command\r\n    * Command\r\n  * Async\r\n* Async\r\n* Command\r\n\r\n\r\nWith `stopWhenNoSuccess` you can decide, if a Sequence Command should stop or carry on, when any Command did execute without success.\r\n\r\nA Sequence Command\r\n\r\n```objective-c\r\n@implementation MySequenceCommand\r\n\r\n- (id)init {\r\n    self = [super init];\r\n    if (self) {\r\n\r\n        self.stopWhenNoSuccess = NO; // Default\r\n\r\n        [self addCommand:[MyAsyncCommand class]];\r\n        [self addCommand:[MyCommand class]];\r\n        [self addCommand:[MyOtherSequenceCommand class]];\r\n    }\r\n\r\n    return self;\r\n}\r\n\r\n@end\r\n```\r\n\r\nAn Async Command\r\n\r\n```objective-c\r\n@implementation MyAsyncCommand\r\n\r\n- (void)execute {\r\n    [self performSelector:@selector(doSth) withObject:nil afterDelay:1];\r\n}\r\n\r\n- (void) doSth {\r\n    [self didExecuteWithSuccess:YES];\r\n}\r\n\r\n@end\r\n```\r\n\r\n## The CommandMap\r\nWhen an instance of MyEvent gets dispatched, all mapped commands get executed\r\n\r\n```objective-c\r\n[commandMap mapAction:[MyCommand class] toTrigger:[MyEvent class]];\r\n\r\n[commandMap mapAction:[MyOtherCommand class] toTrigger:[MyEvent class]\r\n                           removeMappingAfterExecution:YES];\r\n\r\n[commandMap mapAction:[ACommand class] toTrigger:[MyEvent class]\r\n                                        priority: 5];\r\n\r\n[commandMap mapAction:[AnOtherCommand class] toTrigger:[MyEvent class]\r\n                                              priority: 10];\r\n```\r\n\r\nInstead of commands, you can also map blocks\r\n\r\n```objective-c\r\nvoid (^myBlock)(GIInjector *injector);\r\nmyBlock = ^(GIInjector * injector) {\r\n    MyEvent *event = [injector getObject:[MyEvent class]];\r\n    ...\r\n};\r\n\r\n[commandMap mapAction:myBlock toTrigger:[FlagAndStringEvent class]];\r\n```\r\n\r\n## Guards\r\n* Guards do only one thing: approve.\r\n* Guards decide, whether a command gets executed or not.\r\n* Only when all guards approve, a command gets executed.\r\n\r\n```objective-c\r\n@implementation IsInGridGuard\r\ninject(@\"event\", @\"grid\")\r\n\r\n- (BOOL)approve {\r\n    return [self.grid containsPosition:self.event.position];    \r\n}\r\n\r\n@end\r\n```\r\n\r\n#### You can add guards like this:\r\n\r\n```objective-c\r\n[[commandMap mapAction:[DropBombCommand class]\r\n                toTrigger:[DropBombEvent class]]\r\n             withGuards:@[[IsInGridGuard class]]];\r\n```\r\n\r\n## Extensions\r\nPut related configuration logic into extensions and add or remove them at will\r\n\r\n```objective-c\r\n@implementation ServiceExtension\r\n\r\n- (void)configure:(GIInjector *)injector {\r\n    [super configure:injector];\r\n\r\n    // Map commands to events\r\n    [[self mapAction:[DropBombCommand class]\r\n              toTrigger:[DropBombEvent class]]\r\n           withGuards:@[[IsInGridGuard class]]];\r\n\r\n    // Set injection rules\r\n    [self mapEagerSingleton:[MyService class] to:@protocol(RemoteService)];\r\n}\r\n\r\n- (void)unload {\r\n    Service *service = [_injector getObject:@protocol(RemoteService)];\r\n    [service close];\r\n\r\n    // All mappings from the CommandMap and the Injector made\r\n    // in this module get removed automatically.\r\n\r\n    [super unload];\r\n}\r\n```","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Gummi Commander","tagline":"Event Command Mapping System for Objective-C"}